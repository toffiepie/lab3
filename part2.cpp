#include <stdlib.h>
#include <iostream>
//В данном коде, функции stackMemory1 и stackMemory2 создают локальные переменные a и b соответственно и возвращают указатели на них. 
// Однако, эти указатели становятся недействительными после завершения соответствующих функций. 


int* stackMemory1()
{
    int a = 1;
    return &a;
}

int* stackMemory2()
{
    int b = 2;
    return &b;
}

int main()
{
    int* b = stackMemory1(); // Вызывается функция stackMemory1, которая создает переменную a и возвращает указатель на неё. Переменная a имеет значение 1. Затем этот указатель сохраняется в переменной b.
    int a1 = *b; //Значение, на которое указывает указатель b, присваивается a1. В данном случае, a1 становится равным 1.
    int* c = stackMemory2(); // Теперь вызывается функция stackMemory2, которая создает переменную b и возвращает указатель на неё. Переменная b имеет значение 2. Затем этот указатель сохраняется в переменной c.
    int a2 = *c; // Значение, на которое указывает указатель c, присваивается a2. В данном случае, a2 становится равным 2.
    int a3 = *b; // Теперь вы пытаетесь получить значение переменной a через указатель b.Однако, это не сработает, потому что переменная a больше не существует, так как stackMemory1 завершила свою работу.Вместо этого, значение переменной b из stackMemory2 будет использовано, и a3 тоже будет равно 2.

    std::cout << a1 << std::endl; //a1 равно 1, так как это значение переменной a из stackMemory1.
    std::cout << a2 << std::endl; //a2 равно 2, так как это значение переменной b из stackMemory2. 
    std::cout << a3 << std::endl; //a3 также равно 2, как объяснено выше.
    //Разница между указателями b и c равна 0, так как оба указывают на одну и ту же область памяти.
    std::cout << ((std::byte*)b - (std::byte*)c) << std::endl; 

    return 0;
}